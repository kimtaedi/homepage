<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pattern Background HTML</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        /* CSS for the pattern background */
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            position: relative; /* Needed for z-index of content */
            z-index: 1; /* Ensures content is above the pattern */
            color: white; /* Example text color for content */
            text-align: center;
            height: 100vh !important; /* Ensure body takes full viewport height */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        .pattern-background {
            position: fixed; /* Fixes the pattern to the viewport */
            top: 0;
            right: 0;
            bottom: 0;
            left: 0; /* Makes the div cover the entire screen */
            overflow: hidden; /* Hides any overflowing parts */
            z-index: -99; /* Places it behind all other content */
            width: 100% !important;
            height: 100% !important;
        }

        .pattern-foreground {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Allows clicks to pass through to elements below */
        }

        #patternCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            pointer-events: none;
        }

        /* Media Queries for Aspect Ratio Handling */
        @media (min-aspect-ratio: 16/9) { /* If screen is wider than 16:9 */
            .pattern-foreground {
                height: 300% !important; /* Make pattern much taller */
                top: -100% !important; /* And shift it up to center it vertically */
            }
        }

        @media (max-aspect-ratio: 16/9) { /* If screen is taller than 16:9 */
            .pattern-foreground {
                width: 300% !important; /* Make pattern much wider */
                left: -100% !important; /* And shift it left to center it horizontally */
            }
        }
    </style>
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
</head>
<body>

    <div class="pattern-background">
        <div class="pattern-foreground" id="patternContainer">
            <!-- p5.js canvas will be inserted here -->
        </div>
    </div>



    <script>
        // Processing JSON 파라미터 적용
        const params = {
            cols: 21,
            rows: 20,
            blockW: 168,
            cellGap: 0,
            cellGapV: 156,
            minH: 11,
            maxH: 174,
            stair: 0,
            amp: 140,
            freq: 10,
            blockAngle: 0,
            moveX: 0,
            moveY: 418,
            moveMode: 2,
            widthLR: 125,
            widthCenter: 0,
            widthCenterInv: 101,
            waveDelayX: 16,
            waveDelayY: 8
        };

        // JSON에서 가져온 3D 회전 및 뷰 설정
        let rotX = 0.549778938293457;
        let rotY = -0.1963496208190918;
        let rotZ = 0.3926990032196045;
        const zoomLevel = 0.8; // 줌 레벨 증가로 화면 채움
        const colorMode = 0; // Black only
        const panOffsetX = -200; // X축 오프셋 조정
        const panOffsetY = 0; // Y축 중앙 정렬

        let canvas;
        let isDragging = false;

        function setup() {
            // 캔버스를 컨테이너에 생성
            canvas = createCanvas(windowWidth, windowHeight, WEBGL);
            canvas.parent('patternContainer');
            canvas.id('patternCanvas');
        }

        function draw() {
            background(255); // 흰색 배경
            
            // 3D 카메라 설정 (Processing과 동일한 좌표계)
            push();
            translate(width/2 + panOffsetX, height/2 + panOffsetY, 0); // 화면 중앙 + 패닝
            scale(zoomLevel);
            rotateX(rotX);
            rotateY(rotY);
            rotateZ(rotZ);
            
            noStroke();
            
            // Processing과 동일한 패턴 렌더링 로직
            for (let x = 0; x < params.cols; x++) {
                for (let y = 0; y < params.rows; y++) {
                    let t = frameCount * 0.04 * params.freq * 0.07;
                    
                    // 셀별 파동 지연
                    let delayX = x * (params.waveDelayX * 0.01);
                    let delayY = y * (params.waveDelayY * 0.01);
                    let wave = sin(t + delayY + delayX) * params.amp;
                    
                    let h = (params.amp == 0) ? params.maxH : map(wave, -params.amp, params.amp, params.minH, params.maxH);
                    let stairOffset = y * params.stair;
                    
                    // 움직임 애니메이션 (Processing과 동일)
                    let moveWaveX = 0, moveWaveY = 0;
                    if (params.moveMode == 0) {
                        moveWaveX = sin(t * 0.8 + y * 0.2 + x * 0.15) * params.moveX;
                        moveWaveY = sin(t * 0.6 + y * 0.25 + x * 0.1) * params.moveY;
                    } else if (params.moveMode == 1) {
                        moveWaveX = sin(t * 0.8 + y * 0.3) * params.moveX;
                        moveWaveY = sin(t * 0.6 + y * 0.3) * params.moveY;
                    } else if (params.moveMode == 2) {
                        moveWaveX = sin(t * 0.8 + x * 0.3) * params.moveX;
                        moveWaveY = sin(t * 0.6 + x * 0.3) * params.moveY;
                    }
                    
                    // 가로 폭 그라디언트 계산
                    let widthMultiplier = 1.0;
                    if (params.widthLR != 0 || params.widthCenter != 0 || params.widthCenterInv != 0) {
                        let normalizedX = x / max(1, params.cols - 1);
                        
                        if (params.widthLR > 0) {
                            let exponentialX = normalizedX * normalizedX * normalizedX;
                            widthMultiplier += (exponentialX * params.widthLR * 0.025);
                        } else if (params.widthLR < 0) {
                            let leftBias = (1.0 - normalizedX);
                            let exponentialLeft = leftBias * leftBias * leftBias;
                            widthMultiplier += (exponentialLeft * abs(params.widthLR) * 0.025);
                        }
                        
                        if (params.widthCenter != 0) {
                            let centerDistance = abs(normalizedX - 0.5) * 2.0;
                            widthMultiplier += (centerDistance * params.widthCenter * 0.01);
                        }
                        
                        if (params.widthCenterInv != 0) {
                            let centerDistance = abs(normalizedX - 0.5) * 2.0;
                            widthMultiplier += ((1.0 - centerDistance) * params.widthCenterInv * 0.01);
                        }
                    }
                    widthMultiplier = constrain(widthMultiplier, 0.01, 50.0);
                    
                    let actualBlockW = params.blockW * widthMultiplier;
                    
                    // X 위치 누적 계산 (Processing과 동일)
                    let cumulativeXpos = -(params.cols * params.blockW + (params.cols - 1) * params.cellGap) / 2.0;
                    for (let i = 0; i < x; i++) {
                        let tempMultiplier = 1.0;
                        if (params.widthLR != 0 || params.widthCenter != 0 || params.widthCenterInv != 0) {
                            let tempNormalizedX = i / max(1, params.cols - 1);
                            
                            if (params.widthLR > 0) {
                                let exponentialX = tempNormalizedX * tempNormalizedX * tempNormalizedX;
                                tempMultiplier += (exponentialX * params.widthLR * 0.025);
                            } else if (params.widthLR < 0) {
                                let leftBias = (1.0 - tempNormalizedX);
                                let exponentialLeft = leftBias * leftBias * leftBias;
                                tempMultiplier += (exponentialLeft * abs(params.widthLR) * 0.025);
                            }
                            
                            if (params.widthCenter != 0) {
                                let centerDistance = abs(tempNormalizedX - 0.5) * 2.0;
                                tempMultiplier += (centerDistance * params.widthCenter * 0.01);
                            }
                            
                            if (params.widthCenterInv != 0) {
                                let centerDistance = abs(tempNormalizedX - 0.5) * 2.0;
                                tempMultiplier += ((1.0 - centerDistance) * params.widthCenterInv * 0.01);
                            }
                        }
                        tempMultiplier = constrain(tempMultiplier, 0.01, 50.0);
                        cumulativeXpos += (params.blockW * tempMultiplier) + (params.cellGap * tempMultiplier);
                    }
                    
                    let xpos = cumulativeXpos + moveWaveX + stairOffset;
                    let ypos = (y - params.rows / 2.0) * (params.maxH + params.cellGapV) + moveWaveY + (params.maxH - h) / 2;
                    
                    // 3D 블록 렌더링 (Processing의 rect 방식으로)
                    push();
                    translate(xpos + actualBlockW / 2, ypos + h / 2, 0);
                    rotate(radians(params.blockAngle));
                    
                    let rectWidth = params.cellGap == 0 ? actualBlockW : actualBlockW - 2;
                    
                    // 단일 색상 모드 - #0ebf00
                    fill("#0ebf00");
                    
                    // Processing과 동일하게 rect 대신 box 사용하되 더 평면적으로
                    box(rectWidth, h, 10); // Z축 깊이를 10으로 고정
                    pop();
                }
            }
            
            pop();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }

        // 마우스 및 터치 인터랙션 (PC/모바일 대응)
        function mousePressed() {
            isDragging = true;
            return false; // 기본 이벤트 차단
        }

        function mouseDragged() {
            if (isDragging) {
                // Y 마우스 이동 → X축 회전
                rotX += (mouseY - pmouseY) * 0.01;
                // X 마우스 이동 → Y축 회전
                rotY += (mouseX - pmouseX) * 0.01;
                
                // 회전 각도 제한 (너무 많이 돌지 않게)
                rotX = constrain(rotX, -PI/2, PI/2);
            }
            return false;
        }

        function mouseReleased() {
            isDragging = false;
            return false;
        }

        // 터치 이벤트 (모바일 대응)
        function touchStarted() {
            isDragging = true;
            return false;
        }

        function touchMoved() {
            if (isDragging && touches.length === 1) {
                // 이전 터치 위치 계산
                let prevTouchX = touches[0].x - (mouseX - pmouseX);
                let prevTouchY = touches[0].y - (mouseY - pmouseY);
                
                // 터치 이동량으로 회전
                rotX += (touches[0].y - prevTouchY) * 0.01;
                rotY += (touches[0].x - prevTouchX) * 0.01;
                
                rotX = constrain(rotX, -PI/2, PI/2);
            }
            return false;
        }

        function touchEnded() {
            isDragging = false;
            return false;
        }
    </script>

</body>
</html>
